---
title: "Aplicação do algoritmo PSF a séries de vazão naturalizada"
author: "Jerônimo Acker D'Ornellas"
date: "08/04/2021"
output: html_document
---


```{r setup, include=FALSE}
#rm(list = ls())
knitr::opts_chunk$set(
  #echo = FALSE,
  comment = "#>",
  collapse = TRUE
)
```

## Objetivo 

O objetivo do testePSF é realizar a aplicação do algoritmo PSF em séries hidrológicas e comparar o desempenho do algoritmo com outros métodos univariados amplamente usados para os dados da bacia hidrográfica do posto ONS de código 74.

## Pré-requisitos

Pacotes necessários:


```{r, message=FALSE}
if(!require(PSF)) remotes::install_github("neerajdhanraj/PSF")

pacotes <- c(
  "here",
  "usethis",
  "data.table",
  "HEobs",
  "PSF",
  "tidyverse",
  "lubridate",
  "fs",
  "checkmate",
  "xts",
  "hydroGOF",
  "ModelMetrics",
  "forecast",
  "timetk"
)
# Carregar os pacotes
easypackages::libraries(pacotes)
```

Scripts:

```{r}
source(here('R', 'load-data.R'))
source(here('R', 'utils.R'))
```


### Dados de vazão

Os dados importados de vazão devem ser regularmente espaçados no tempo. Esta adequação das séries diárias, se necessária, pode ser realizada com a função `complete_dates()` do pacote **`{lhmetools}`**. Assim assegura-se que todas estações possuam 1 observação por dia e sem datas faltantes.

```{r}
qnat_data <- qnat_dly_ons() %>%
  select(date, qnat, code_stn) %>%
  lhmetools::complete_dates(group = "code_stn")
glimpse(qnat_data)
```

Os dados importados precisam filtrados para o posto de interesse: posto 74 da ONS (G. B. Munhoz).

```{r}
posto <- 74
qnat_posto <- qnat_data %>% 
  dplyr::filter(code_stn == posto)
glimpse(qnat_posto)
```


Observam-se dados faltantes na série do posto 74, então selecionaremos somente os meses com mais pelo menos 28 observações válidas e anos completos.
```{r}
# Seleciona observações com pelo menos 28 observações válidas no mês
qnat_posto_mly <- qnat_posto %>% 
  dplyr::group_by(date = floor_date(date, "month"), code_stn) %>% 
  dplyr::summarise(
    qnat_obs = mean_wise(qnat), 
    valid = nvalid(qnat), 
    N = n(),
    .groups = "drop"
  ) %>%
  dplyr::filter(valid >= 28) 

# check
#str(qnat_posto_mly)
# qnat_posto_mly %>% 
#   lhmetools::complete_dates(group = "code_stn", time_step = # "month") %>%
#   str()



# Anos completos
anos_comp <- qnat_posto_mly %>%
  group_by(ano = lubridate::year(date)) %>%
  tally() %>%
  filter(n == 12) %>%
  pull(ano) 
# Usa apenas as observações dos anos completos
qnat_posto_mly <- qnat_posto_mly %>%
  filter(lubridate::year(date) %in% anos_comp)
# check
#qnat_posto_mly %>%
#  filter(valid != N)
# Seleciona apenas a data e as observações de vazão 
qnat_posto_mly <- qnat_posto_mly %>%
  select(date, qnat_obs)
```

É necessário especificar na função `psf` do pacote `PSF` o número de valores que caracterizam um ciclo na série temporal caso os dados não estejam no formato `ts`. No código abaixo realizamos a verificação se a série do posto 74 está no formato correto, isto é, se o número de observações é múltiplo do ciclo.

```{r}
# check
head(qnat_posto_mly)
tail(qnat_posto_mly)
nrow(qnat_posto_mly) %% 12 
nrow(qnat_posto_mly) %/% 12
```




### Aplicação do algoritmo PSF

Os dados usados para o treinamento do modelo abrangeu os anos de 1969 a 2016 e, dessa forma, as predições foram feitas para os anos de 2017 e 2018. No gráfico da série temporal podemos visualizar as predições destacadas na cor azul.

```{r}
#PSF:::convert_datatype(data = qnat_posto_mly["qnat_obs"])

# Retirar observações dos dois últimos anos: 2017 e 2018
(leave_out <- tail(anos_comp, n = 2))
data_train <- qnat_posto_mly %>%
  filter(!lubridate::year(date) %in% leave_out)

# Treinamento do modelo
set.seed(123)
modelo_munhoz <- psf(
  data_train[["qnat_obs"]],
  #n.ahead = 12 * length(leave_out),
  #k = 2:20,
  k = 3:20,
  w = 1:10,
  cycle = 12
)

# Realiza a previsão de vazão nos dois últimos meses (2017 e 2018)
pred_munhoz <- predict(modelo_munhoz,
                       n.ahead = 12 * length(leave_out))

# Comparação dos valores observados e previstos para os dois últimos anos
plot(
  modelo_munhoz,
  pred_munhoz
  )
```



Adicionando previsões aos dados originais para previsão.

```{r}
inds <- (nrow(data_train) + 1):(nrow(data_train) + (12 * length(leave_out)))
nrow(qnat_posto_mly) == max(inds)

qnat_posto_mly_pred <- mutate(qnat_posto_mly,
  qnat_pred = NA,
  qnat_pred = replace(qnat_pred,
    list = inds,
    values = pred_munhoz
  )
)
tail(qnat_posto_mly_pred, 12 * length(leave_out) + 1)
```

No gráfico iremos comparar os valores das previstos pelo *PSF* e os valores observados da série de vazão naturalizada para os anos de 2017 e 2018. Observa-se que a série hidrológica do posto 74 apresenta uma relação sinal ruído alta. Em decorrência disso as predições do método `PSF`, que busca selecionar padrões específicos e realizar as predições com base em valores passados, foram bastante diferentes dos valores observados.

```{r}
df <- qnat_posto_mly_pred[inds,]
df_ts <- xts(df[,-1], order.by = as.Date(df[["date"]]))
forecast::autoplot(df_ts, facets = FALSE)
```


## Avaliação do PSF


Selecionamos algumas métricas para realizar uma avaliação quantitativa do `PSF` no posto 74.

```{r}
# Seleciona apenas alguns índices
pos_stat_inds <- c(1:2, 4:6, 9, 17, 19:20) 
hydroGOF::gof(
  sim = df_ts$qnat_pred, 
  obs = df_ts$qnat_obs)[pos_stat_inds,]
```

Podemos avaliar a média do [KGE](https://www.rdocumentation.org/packages/hydroGOF/versions/0.4-0/topics/KGE) após dez iterações para obter uma resposta mais robusta do desempenho das predições feitas pelo PSF.


```{r}
obs_74 <- df$qnat_obs
metricas74 <- NULL

for(i in 1:10)
{
  # i = 1
  set.seed(i)
  # PSF
  psf_model <- psf(data_train[["qnat_obs"]],
                   k = 3:20,
                   w = 1:10,
                   cycle = 12)
  preds <- predict(psf_model, 
                   n.ahead = 12 * length(leave_out))
  # Erro do PSF
 # metricasx[i] <-  sqrt(mean((df_ts$qnat_obs- preds)^2))
  metricas74[i] <- KGE(sim = preds,
                       obs = obs_74)
}


(KGE74_psf <- mean(metricas74))
```



## Aplicação do PSF a outros postos da ONS


```{r}
# Média mensal das observações de vazão para todos os postos
qnat_mly <- qnat_data %>% 
  apply_cmonth(.) %>% 
  group_by(code_stn) %>% 
  nest() %>% 
  mutate(
    data = map(data, apply_cyears)
  )

# Dados de treinamento (sem últimos dois anos)
train_qmly <- qnat_mly  %>% 
  mutate(data = map(data, get_traindt))


# Dados para avaliação do PSF 
test_qmly <- qnat_mly %>% 
  mutate(qnat_obs = map(data,get_testdt)) %>% 
  select(code_stn,qnat_obs)

# Vazão simulada (resultados reprodutíveis)
preds_qmly <- train_qmly %>% 
  mutate(qnat_pred = map(data,
                         ~psf_reprod(.x, ret = "preds"))) 

# Predições e observações
pobs_qmly <- preds_qmly %>% 
  inner_join(.,
             test_qmly,
             by = "code_stn") %>% 
  select(-data) %>% 
  unnest()


aval_qmly <- pobs_qmly %>% 
  group_by(code_stn) %>%
  summarise(mKGE = KGE(sim = qnat_pred, obs = qnat_obs),
            mPBIAS = pbias(sim = qnat_pred, obs = qnat_obs),
            mNSE = NSE(sim = qnat_pred, obs = qnat_obs),
            RMSE = ModelMetrics::rmse(actual = qnat_obs,
                                  predicted = qnat_pred),
            mNRMSE = nrmse(sim = qnat_pred, obs = qnat_obs)
            ) %>% 
  arrange(-mKGE)

print(aval_qmly)
```


## Aplicação do ensemble PSF


```{r}
# Modelos e predições resultantes de 5 iterações para cada posto

# start_time <- Sys.time()
# esb_qmly <- train_qmly %>% 
#   mutate(
#     models = map(data,ensemble_models),
#     preds = map(data,ensemble_preds)
#   )
# end_time <- Sys.time() # Demorou 8.775542 mins

#saveRDS(ensemble_postos_all, file = here('doc', 'ensemble_all.rds'))
esb_qmly <- readRDS(here('doc', 'ensemble_all.rds'))

# Predições e observações do ensemble
pobqmly_esb <- esb_qmly %>% 
  mutate(
    mparam_qmly = map(models,get_mpar), # parâmetros k e w médios
    qnat_mpred = unlist(map(preds,get_mpred),
                        recursive = FALSE), # predições médias das iter
    qnat_mpar = map(train_data, # predições usando k e w médios
                    ~ensemble_mpar(.x,mparam_qmly))
  ) %>% 
   inner_join(.,
             test_qmly,
             by = "code_stn") %>% 
  select(qnat_obs,qnat_mpred,qnat_mpar) %>% 
  unnest() 



aval_ensemble <- pobqmly_esb %>% 
  summarise(KGE_mpred = KGE(sim = qnat_mpred, obs = qnat_obs),
            KGE_mpar = KGE(sim = qnat_mpar, obs = qnat_obs),
            mPBIAS = pbias(sim = qnat_mpred, obs = qnat_obs),
            mNRMSE = nrmse(sim = qnat_mpred, obs = qnat_obs),
            mNSE(sim = qnat_mpred, obs = qnat_obs)
  ) %>% 
  arrange(-KGE_mpred)

(aval_ensemble)
```


Comparação das predições do modelo PSF para os anos de 2017 e 2018 com os valores observados de vazão naturalizada para o posto 287 da ONS.

```{r}
# Gráfico 
qnat_posto287 <- pobqmly_esb %>% 
  sel_station(.,287) %>% 
  select(date,qnat_obs,qnat_mpred)# melhor KGE usando qnat_mpred

posto287_xts <- xts(qnat_posto287[,c("qnat_obs","qnat_mpred")], 
                   order.by = as.Date(qnat_posto287[["date"]]))
forecast::autoplot(posto287_xts, facets = FALSE)
```


## Validação cruzada aplicada ao posto 287 considerando um horizonte de um ano

```{r}
qnatmly_287 <- qnat_mly %>% # dados completos
  sel_station(.,287) %>% 
  unnest() %>% 
  ungroup() %>% 
  select(date,qnat_obs)

# Dados de treinamento sem o último ano
train287_qmly <- get_traindt(qnatmly_287,yrs = 1)

# Dados para avaliação do PSF 
test287_qmly <- get_testdt(qnatmly_287,n = 12)

resample_spec <- time_series_cv(data = qnatmly_287,
                                assess      = "12 months",# df teste inicial
                                skip        = "12 months",
                                cumulative  = TRUE,
                                slice_limit = 40) # valor ótimo 40


qmly287_slices <- resample_spec %>% tk_time_series_cv_plan() %>%
  nest(date,qnat_obs) %>% 
  pivot_wider(names_from = .key,values_from = data)

# Predições usando um horizonte de 12 meses
cv287_qmly <- qmly287_slices %>% 
  mutate(
    model = map(training,
                ~psf_reprod(.x,n = 12, ret = "model") # para extrair os parâmetros
                ),
    cvparams = map(model,get_cvpar) # extrai os parâmetros k e w 
  )

# Parâmetros k e w médios
# Soma os elementos dos vetores e divide pelo número de slices
cvm_params <- round(Reduce("+",cv287_qmly[["cvparams"]])
                    /length(cv287_qmly[["cvparams"]]),0)



# Os parâmetros médios obtidos na validação cruzada são aplicados no modelo 
preds287_qmly <- psf_cvparam(train287_qmly,
                             params = cvm_params)

# As predições são adicionadas aos valores observados 
pobs287_qmly <- mutate(test287_qmly,
                  qnat_pred = NA,
                  qnat_pred = replace(qnat_pred,
                    values = preds287_qmly
                  )
) 

avalcv_287 <- pobs287_qmly %>% 
  summarise(KGE = KGE(sim = qnat_pred, obs = qnat_obs)
  ) 
(avalcv_287)
```

```{r}
cv287_xts <- xts(pobs287_qmly[,c("qnat_obs","qnat_pred")], 
                   order.by = as.Date(pobs287_qmly[["date"]]))
forecast::autoplot(cv287_xts, facets = FALSE)
```

## Validação cruzada aplicada aos postos que apresentaram os melhores KGE 


```{r}
qnatmly_cv <- qnat_mly %>% # dados completos
 dplyr::filter(code_stn == 287|
               code_stn == 295|
               code_stn == 145|
               code_stn == 281|
               code_stn == 278|
               code_stn == 291|
               code_stn == 279|
               code_stn == 99|
               code_stn == 277|
               code_stn == 190)

traincv_qmly <- qnatmly_cv %>% 
  mutate(
    data = map(data,
               ~get_traindt(.x,yrs = 1))
  )
                  
testecv_qmly <- qnatmly_cv %>% 
  mutate(
    data = map(data,
               ~get_testdt(.x,n = 12))
  )


# Simplificar
slicescv_qnatmly <- traincv_qmly %>% 
mutate(
  slices = map(data,
              ~time_series_cv(.x,
                assess = "12 months",
                skip = "12 months",
                cumulative = TRUE,
                slice_limit = 20)),
  slices_plan = map(slices,tk_time_series_cv_plan),
  nested_slices = map(slices_plan,
                      ~nest(.,date,qnat_obs)),
  wider_slices = map(nested_slices,
                     ~pivot_wider(.,
                                  names_from = .key,
                                  values_from = data))
)


# Parâmetros de cada slice agrupados pelo código do posto
# Para reduzir tempo de simulação, diminuir o número de slices
wqnatmly_cv <- slicescv_qnatmly  %>% 
  select(wider_slices) %>% 
  unnest() %>% 
  mutate(
    model = map(training,
                ~psf_reprod(.x,n = 12, ret = "model") # para extrair os parâmetros
                ),
    cvparams = map(model,get_cvpar), # extrai os parâmetros k e w 
  ) %>% 
  select(code_stn,cvparams) %>% 
  group_by(code_stn)


# Parâmetros médios de k e w de cada posto
wqnat_cvmpar <- wqnatmly_cv %>% 
  nest() %>% 
  mutate(
    cvm_params = map(data,getcv_mpar)
  ) %>% 
  select(cvm_params)


# Vazão prevista usando os parâmetros médios retornados na validação cruzada
preds_cvqmly <- train_qmly %>% 
  inner_join(.,
             wqnat_cvmpar,
             by = "code_stn") %>% 
  mutate(qnat_cvpred = map(data,
                         ~ensemble_mpar(.x,cvm_params,n = 12))) %>% 
  select(qnat_cvpred)

# Predições e observações agrupadas pelos postos
pobscv_qmly <- preds_cvqmly %>% 
  inner_join(
    .,
    testecv_qmly,
    by = "code_stn"
  ) %>% unnest() %>% 
  select(code_stn,date,everything())


avalcv_qmly <- pobscv_qmly %>% 
  summarise(KGE = KGE(sim = qnat_cvpred, obs = qnat_obs),
            PBIAS = pbias(sim = qnat_cvpred, obs = qnat_obs),
            NRMSE = nrmse(sim = qnat_cvpred, obs = qnat_obs),
            NSE = NSE(sim = qnat_cvpred, obs = qnat_obs),
            RMSE = ModelMetrics::rmse(actual = qnat_obs,
                                      predicted = qnat_cvpred)           
  ) %>% 
  arrange(-KGE)

(avalcv_qmly)
```



