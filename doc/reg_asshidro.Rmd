---
title: Regionalização das principais Bacias hidrográficas do Setor Elétrico Brasileiro
  por meio de assinaturas hidrológicas.
author: "Jerônimo Acker D'Ornellas"
date: "27/09/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Regionalização das principais Bacias hidrográficas do Setor Elétrico Brasileiro
  por meio de assinaturas hidrológicas.

## Objetivo 

O objetivo do testePSF é realizar a aplicação do algoritmo PSF em séries hidrológicas e comparar o desempenho do algoritmo com outros métodos univariados amplamente usados para os dados das bacia hidrográficas da ONS. Neste arquivo aplicaremos a validação cruzada aos postos da ONS. A partir da validação cruzada esperamos obter uma avaliação robusta do desempenho do algoritmo PSF e também selecionar, a partir da busca de um padrão, os parâmetros ótimos.

## Pré-requisitos

Pacotes necessários:

```{r, message=FALSE}
if(!require(PSF)) install.packages("PSF")
if(!require(timetk)) remotes::install_github("business-science/timetk")

pacotes <- c(
  "here",
  "usethis",
  "data.table",
  "HEobs",
  "PSF",
  "tidyverse",
  "lubridate",
  "fs",
  "checkmate",
  "xts",
  "hydroGOF",
  "ModelMetrics",
  "forecast",
  "timetk",
  "EflowStats"
)
# Carregar os pacotes
easypackages::libraries(pacotes)
```


Scripts:

```{r}
source(here('R', 'load-data.R'))
source(here('R', 'utils.R'))
```

### Dados de vazão

Os dados importados de vazão devem ser regularmente espaçados no tempo. Esta adequação das séries diárias, se necessária, pode ser realizada com a função `complete_dates()` do pacote **`{lhmetools}`**. Assim assegura-se que todas estações possuam 1 observação por dia e sem datas faltantes.

```{r}
qnat_data <- qnat_dly_ons() %>%
  select(date, qnat, code_stn) %>%
  lhmetools::complete_dates(group = "code_stn")
glimpse(qnat_data)
```

```{r}
qnat_posto <- qnat_data %>% 
  sel_station(.,station = 74)  
glimpse(qnat_posto)
```


Pré-processamento dos dados do posto 74 para aplicação da função `calc_magnifSeven`.

```{r}
qnat_mly <- qnat_posto %>% 
  apply_cmonth() 

cyrs <- get_cyears(qnat_mly) 

# qnat_mly <- qnat_mly %>% 
#   apply_cyears()

qnat_posto74 <- qnat_posto %>%
  dplyr::group_by(date, code_stn) %>% 
  dplyr::mutate(valid = nvalid(qnat)) %>% 
  dplyr::filter(valid == 1) %>% # elimina dados faltantes
  ungroup() %>% 
  select(date,qnat) %>% 
  filter(lubridate::year(date) %in% cyrs) %>% 
  as.data.frame() #%>% 
  #mutate(qnat = as.integer(qnat))
```


Aplicação da função para obtenção dos sete índices.

```{r}
magSeven <- calc_magnifSeven(qnat_posto74, yearType = "calendar")
```


Pré-processamento dos dados dos 87 postos para aplicação da função `calc_magnifSeven`.

```{r}
# Função para usar para obter os 7 índices
apply_cdaily <- function(df) {
  # Pré-Processamento
  qnat_arrum <- df %>%
  dplyr::group_by(date = floor_date(date, "month")) %>%
  dplyr::summarise(
    qnat_obs = mean_wise(qnat),
    valid = nvalid(qnat),
    N = n(),
    .groups = "drop"
  ) %>%
  dplyr::filter(valid >= 28) %>%
  select(date, qnat_obs)
  # Anos Completos
  cyrs <- get_cyears(qnat_arrum)
  # Dados completos diários
  df_arrum <- df %>% 
    dplyr::group_by(date) %>% 
    dplyr::mutate(valid = nvalid(qnat)) %>% 
    dplyr::filter(valid == 1) %>% # elimina dados faltantes
    select(-c(valid)) %>% 
    ungroup() %>% 
    filter(lubridate::year(date) %in% cyrs) 
  return(df_arrum)
}
```



```{r}
qnat_cdly <- qnat_cdly %>%
  ungroup() %>%
  group_by(code_stn) %>%
  nest() %>%
  mutate(data = map(data, ~ .x %>% 
                    apply_cdaily() %>% 
                      as.data.frame()))
```


Aplicação da função para obtenção dos sete índices.


```{r}
qnat_ids <- qnat_cdly %>%
  mutate(indices = map(data, 
                       calc_magnifSeven, yearType = "calendar"))
```


